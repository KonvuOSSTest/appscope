# Attach to a Running Process

AppScope is able to extract detailed information describing the operation of a running application. This is accomplished by loading a library into the address space of a process and establishing a number of interposed functions. Until recently, the library has been loaded at the time a process is started. With the 0.7 release the ability to attach to a running process is introduced. In this case, attach implies connecting to a running process, loading the library, establishing interpositioned functions and emit metrics and events based on the behavior of the attached process.

## Design
The design approach follows well established patterns. We use `ptrace` to attach to a process. This requires root user access, **SYS_PTRACE** capability in a container and the **PID** of the process to be attached. 

We use `dlopen` to load the libscope library. Therefore, it is a matter of finding the address of `dlopen` in the attach process, setting up parameters and calling `dlopen`.

When libscope is loaded the library constructor is run and it determines that we are attaching and performs GOT hooking on a list of functions. This establishes interposition and detailed data extraction begins.  

![Attach Preview](images/attach1.jpeg)

## Issues
We quickly ran into several issues. 
1. How to configure the library in an attached process
1. All musl libc based processes would segfault when attached
1. python3 segfaults when attached

### Library Configuration
When the libscope constructor runs it looks for environment variables and a config file in several predefined locations. We really wanted the constructor to be able to locate the config created by the `scope` CLI. However, we need to define an environment variable to point to the session dir from the CLI. Passing env vars to a running process is not normally done. So, before executing `ptrace` attach and calling `dlopen` we write the env vars we want the libscope constructor to use into a file in `/dev/shm.` When the constructor runs, it locates the file and exports the defined env vars. This causes libscope to use the config created by the CLI. With this approach, we can attach and then begin interacting with the results using the CLI. For example:

    sudo scope attach PID
    sudo scope events
That command sequence will attach to the process defined by PID. The events generated by the attached process are readily exposed. 
### Debug
Library constructor code is run in the context of the loader, ld.so. This turns out to be a highly constrained context. We can't readily write to stdout or log to files. Moreover, because we are attaching, we can't also attach with a debugger. 

This resulted in drawing a few conclusions by looking at the code and suspected behavior. Of course, the conclusions were all inaccurate. We actually used a form of a breakpoint to see what path was being taken with the code sequence; `while (1) sleep(1)`. That, of course, is ridiculous and didn't help much.

We became convinced that the issues we were seeing were caused, at least in part, by the constructor running multiple times due to calling `dlopen` of libscope multiple times. This turned out not to be the case. We were able to prove that after finding a way to get debug statements out of code running in the constructor. 

We mmap'd a section of unused memory and extended the `scopeLog` function to write to the mapped memory instead of a log file. Then, we caused an interposed function that we know would be called by the application and added a `sleep(30)` at the front of the function. We modified constructor code to not execute code causing the segfault so that we could get through the constructor and get into the interposed function. While in the sleep function we could connect `gdb` and look at the log data in mapped memory. 

In the python3 case, we started the built-in python web server with `python3 -m http.server` and used curl to hit that server with `curl localhost:8000`. We added the `sleep(30)` to the `recv` interposed function. After attaching and loading libscope into the python process we sent a get request to the server with curl and then attached gdb during the 30 second delay. At that point we were able to examine logs in mapped memory.  

Given the ability to see details of constructor execution it became clear that the constructor was called once and only once. With memory based logs we were able to move forward to determine specific issues.
### Musl Libc
The design and implementation of musl libc is impressive. It works well and appears to strictly conform to POSIX and Linux specs. The gnu loader is fully featured and handles all number of corner cases. As such, it is possible to *get away with* behavior that is not strictly correct. Use of ld.musl.so exposed several places where we were *getting away with* things that the gnu loader fixed for us. 

During the attach sequence, the symbol search algorithm used by ld.musl.so requires that the search starts with the executable object and not the next object. This implies that `dlsym` needs to use the `RTLD_DEFAULT` handle and not `RTLD_NEXT`. When `RTLD_NEXT` is used the symbols required in the `g_fn` structure are not resolved and that, of course, causes issues. The requirement to start at the executable makes sense in the context of attach. This required that we determine if we are attaching at the time `g_fn` is initialized. That required a bit of thought. In the end, a simple approach is in place.

The next issue we encountered using ld.musl.so was in walking through all the dynamic symbols in the attached process during constructor execution. The address values defined in the .dynamic section are virtual addresses that should be computed based on the original file value and the memory base address. In some cases, on a glibc distro, the base address as defined in the link map is 0. Therefore, the address values in a .dynamic section were used directly, without adding a memory base address. This was not the case on a musl libc distro. Of course, attempting to use a `d_un.d_ptr` from a .dynamic section without adjusting to the base address causes a segfault where the base address needs to be applied. Therefore, adding the base address from the corresponding link map resolves the issue. Which is, of course, correct behavior.

In other cases, we found that the virtual addresses were not an offset and the base address was not 0. Of course, in this case the base address can not be added to a `d_un.d_ptr`. Given the apparent variation we added a check to determine if the address defined in a `d_un.d_ptr`can be found in the process address space. If it is found, we do not add a base address. While this approach feels a bit uncomfortable it appears to function correctly in all test cases. 
### Python3
The issue with python3 turned out to be difficult to understand. Once we understood, it was a one line code change. The issue originated in the GOT hooking code.

When GOT hooking we have 2 arrays that need to be managed; 1) the GOT entries and 2) the `g_fn` entries. The GOT entries are updated to cause the interposed function to be called by the application. The `g_fn` functions represent the original function called from the interposed function.

![Attach and the GOT](images/attach2.jpeg)

Once we were able to see details by using the memory based logs it became clear that the GOT entries were accurate. The location of the GOT and entries along with the values being updated were accurate. When we update the GOT entry we assign the previous GOT entry to the corresponding `g_fn` entry. For example, the GOT entry for `fclose` is updated to call the `fclose` interposed function in libscope and `g_fn.fclose` is updated with the original value from the GOT entry. Works great...except in the case where the `g_fn` function is used during constructor execution.

There are 2 values that the original GOT entry will have; 1) the value assigned at initial load time when lazy loading is used and 2) the actual value of the function used by the application. 

We experienced functions that worked as expected, some with initial values from lazy loading and some with glibc values. We also experienced fclose causing a segfault. Several functions are used in the context of the libscope constructor. Why does fclose cause a segfault and others not? When we disabled lazy loading by setting the `LD_BIND_NOW` env var, `fclose` worked without issue. So, we knew that lazy loading was a factor, but still could not tell why some functions appeared to work with GOT entries with initial values and `fclose` did not.

Further analysis of the GOT activity revealed that `fclose` was unique in that its' GOT entry was initial, from lazy loading, and it was called in a constructor context. Other functions whose GOT entries were initial were not being called in the constructor context. The fact that `fclose` worked when lazy loading was disabled meant that the GOT entry for `fclose` was from glibc in a direct link mode. 

So, functions with initial GOT entries and not called in the constructor do not result in a segfault while functions with initial GOT entries and called in the constructor result in a segfault. This implies that ld.linux.so behaves differently when the lazy loader code is executed when a library is being loaded from `dlopen`. The glibc code for `dlopen` does include an ability to recognize an initialized and active ld.so. This implies that there is a difference in function resolution in a library constructor context.

In recognition of the difference in initial GOT entry value in a library constructor context, we added a check in the GOT hook code that does not update the `g_fn` value if we are attaching. This resolves the segfault caused by `fclose` and allows attach to a python3 process without issue. The good side of this change means that we do not need to make exceptions in use of `g_fn` functions when executed in the constructor. Should an application update a GOT entry we will ignore it. That may pose a problem that will require us to change this approach. For now, we have taken steps to understand the behavior of initial value updates by ld.linux.so and that has allowed us to proceed with attach behavior.
